<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Network Graph</title>
  <style>
    @font-face {
      font-family: 'SFPro';
      src: url('SF-Pro-Display-Black.otf') format('opentype'); /* Path relative to your HTML file */
      /* You can add additional font formats for better browser compatibility */
    }

    @font-face {
      font-family: 'SFProDisplayMedium';
      src: url('SF-Pro-Display-Medium.otf') format('opentype');
    }

    @font-face {
      font-family: 'SFProRoundedRegular';
      src: url('SF-Pro-Rounded-Regular.otf') format('opentype');
    }
  
    body {
      font-family: 'SFPro', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
      /* Use 'SFPro' as the primary font, with fallbacks for different operating systems */
      margin: 0;
      padding: 0;
      background-color: #f0f0f0;
      color: #333;
      justify-content: center; /* Center content horizontally */
      align-items: center; /* Center content vertically */
      height: 100vh; /* Full viewport height */
    }
  
    .node-label {
      font-family: 'SFPro', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
      /* Apply 'SFPro' to specific elements like node labels */
      text-anchor: middle;
      dominant-baseline: hanging;
    }
  
    h1 {
      text-align: center;
      margin-top: 10px;
      font-family: 'SFPro', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
      /* Apply 'SFPro' to headings as well */
    }
  
    #graph-container {
      width: 100vw;
      height: calc(100vh - 100px); /* Adjusted height to leave space for the legend and title */
      border: 1px solid #ccc;
      position: relative;
      overflow: hidden;
      z-index: 0;
    }

    #legend-container {
      background-color: #fff;
      padding: 20px;
      border: 1px solid #ccc;
      text-align: center;
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 1;
      max-width: 200px; /* Adjust width as needed */
    }

    .legend-item {
      margin-bottom: 10px; /* Spacing between legend items */
    }

  #show-legend {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 2;
    cursor: pointer;
  }

  #search-container {
  text-align: center;
  margin-top: 20px;
  position: fixed;
  top: 50px;
  left: 92%;
  transform: translateX(-50%);
  z-index: 10;
  width: 240px; /* Adjust width as needed */
  background-color: #fff;
  border: 1px solid #ccc;
  padding: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

#node-search {
  padding: 8px;
  width: 180px;
  font-size: 14px;
}

    .legend {
      position: absolute;
      font-size: 14px;
      margin-top: 20px;
      text-align: center;
      z-index: 1;
      visibility: 1;
      opacity: 1; /* Initially visible */
      pointer-events: auto;
      transition: opacity 0.3s ease; /* Smooth transition for opacity */
    }
  
    .legend-item {
      font-size: 11px;
      margin-right: 0px;

    }
  
    .node {
      stroke: #fff;
      stroke-width: 1.5px;
    }
  
    .link {
      stroke: #333;
      stroke-opacity: 0.6;
    }
  
    .node.active {
      font-weight: bold; /* Make active nodes bold */
    }
  
    .node.inactive,
    .link.inactive {
      opacity: 0.3; /* Make inactive nodes and links semi-transparent */
    }

    .legend.hidden {
      opacity: 0;
      pointer-events: none;
      visibility: hidden;
    }
  </style>
  
  
</head>
<body>
  <h1 style="text-align: center;">Sparrow Gen Framework</h1>
  
  <div id="show-legend" onclick="showLegend()">
    Show Legend
  </div>
  
  <div id="legend-container" class="legend hidden">
  </div>
  

  <div id="graph-container"></div>

  <div id="search-container">
    <input type="text" id="node-search" placeholder="Search Node Name..." oninput="searchNode()">
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>

    let nodes = [];
    let links = [];

    let svg;

    let clickedActive = false;

    const circleLayouts = {
      "Activity Type Name": {center: [-275, -160], radius: 50},
      "Activity Name": {center: [-100, -150], radius: 100},
      "Excercise Name": {center: [200, -70], radius: 50},
      "Drill Name": {center: [350, 200], radius: 100},
      "Skill Name": {center: [-120, 50], radius: 50},
      "Professional Name": {center: [150, -50], radius: 30},
      "Equipment Name":{center: [300, 200], radius: 100},
      "Brand Name": {center: [350, 200], radius: 100},
      "Rule Name": {center: [100, -150], radius: 100},
      "Excercise Type Name": {center: [200, -100], radius: 40},
      "Motion Name": {center: [200, -20], radius: 100},
      "Analysis Name": {center: [200, 250], radius: 100},
      "Methodology Name": {center: [200, 300], radius: 100},
    }

d3.json("activities2.json").then(function(data) {
    console.log("Data loaded:", data); // Check if data is loaded correctly
    nodes = data.nodes;
    links = data.links;

    // Check if 'nodes' and 'links' are properly loaded
    if (nodes && nodes.length > 0) {
        // Call any functions that rely on 'nodes' here, e.g., searchNode()
        searchNode(); // Example of calling searchNode after data is loaded
    } else {
        console.log("Failed to load or empty 'nodes' array.");
    }

    nodes.forEach(d => {
      const layout = circleLayouts[d.type];
  if (layout) {
    const initialRadius = layout.radius * 0.2;
    const angle = (nodes.filter(n => n.type === d.type).indexOf(d) / nodes.filter(n => n.type === d.type).length) * 2 * Math.PI;
    d.x = layout.center[0] + initialRadius * Math.cos(angle);
    d.y = layout.center[1] + initialRadius * Math.sin(angle);
  }
});

links.forEach(link => {
    link.source = nodes.find(node => node.id === link.source);
    link.target = nodes.find(node => node.id === link.target);
});


      // Create SVG container
      svg = d3.select("#graph-container")
              .append("svg")
              .attr("viewBox", "0, 0, 800, 600") 
              .call(d3.zoom()
                .scaleExtent([0.1, 10]) // Define the zoom scale extent
                .on("zoom", function(event) {
                  svg.attr("transform", event.transform);
                  toggleVisibility(event.transform.k); // Toggle label visibility based on zoom level
                })
              )
              .on("click", unclicked) // Add unclick event listener
              .append("g");

    const colorScheme = {
                "Activity Type Name": "#E5972A", // Blue
                "Activity Name": "#F24822",      // Orange
                "Excercise Name": "#0D99FF",     // Green
                "Drill Name": "#0D99FF",         // Red
                "Skill Name": "#9467bd",          // Purple
                "Professional Name": "#AFF4C6",
                "Equipment Name": "#FF00A8",
                "Brand Name": "#BDE3FF",
                "Rule Name": "#FFC7C2",
                "Excercise Type Name": "#9747FF",
                "Motion Name": "#FF00A8",
                "Analysis Name": "#14AE5C",
                "Methodology Name": "#E5972A" 
                };

      // Define color scale for node types
      const colorScale = d3.scaleOrdinal()
                          .domain(Object.keys(colorScheme))
                          .range(Object.values(colorScheme));

      // Create curved lines using BÃ©zier curves
      const linkPath = d3.linkHorizontal()
                        .x(d => d.x)
                        .y(d => d.y);

      // Draw links as curved paths
      const link = svg.selectAll(".link")
                    .data(links)
                    .enter().append("path")
                    .attr("class", "link")
                    .attr("stroke", "#999")
                    .attr("stroke-width", 0.075)
                    .attr("fill", "none")
                    .attr("d", d => linkPath({source: d.source, target: d.target}));

      // Create nodes
const node = svg.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("r", d => Math.sqrt(d.size) * 1.5)
                .attr("fill", d => colorScale(d.type))
                .attr("class", d => {
                  if (d.type === "Activity Type Name") return "node activity-type";
                  else if (d.type === "Activity Name") return "node activity";
                  else return "node other";
                })
                .on("click", clicked)
                .call(d3.drag()
                  .on("start", dragstarted)
                  .on("drag", dragged)
                  .on("end", dragended));

// Add node labels with dynamic font size and family based on node type
const labels = svg.append("g")
                  .selectAll("text")
                  .data(nodes)
                  .enter().append("text")
                  .attr("class", "node-label")
                  .attr("dy", d => Math.sqrt(d.size) * 1.5 + 10)
                  .style("font-size", d => {
                    // Set font sizes here as needed
                    // Example:
                    if (d.type === "Activity Type Name") return "10px";
                    else if (d.type === "Activity Name") return "7px";
                    else return "4px";
                  })
                  .style("font-family", d => {
                    // Set font families based on node types
                    if (d.type === "Activity Type Name") return "'SFProDisplayMedium', sans-serif";
                    else if (d.type === "Activity Name") return "'SFPro', sans-serif";
                    else return "'SFProRoundedRegular', sans-serif";
                  })
                  .style("alignment-baseline", "middle") // Center align text vertically
                  .text(d => d.id)
                  .style("visibility", "hidden"); // Initially hidden

      // Create legend
      const legendContainer = d3.select("#legend-container");
      const legend = legendContainer.selectAll(".legend-item")
                                    .data(colorScale.domain())
                                    .enter().append("div")
                                    .attr("class", "legend-item");
      legend.append("span")
            .style("background-color", colorScale)
            .text(d => d);
      legend.append("span")
            .text(d => ` (${nodes.filter(node => node.type === d).length} nodes)`);
      
            // Preprocess data: Sort nodes by type
nodes.sort((a, b) => {
  if (a.type < b.type) return -1;
  if (a.type > b.type) return 1;
  return 0;
});

// Create boundary checks during simulation
const boundaryForce = (d) => {
  const layout = circleLayouts[d.type];
  if (layout) {
    const dx = d.x - layout.center[0];
    const dy = d.y - layout.center[1];
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance > layout.radius) {
      const angle = Math.atan2(dy, dx);
      d.x = layout.center[0] + layout.radius * Math.cos(angle);
      d.y = layout.center[1] + layout.radius * Math.sin(angle);
    }
  }
};


// Update the simulation
const simulation = d3.forceSimulation(nodes)
  .force("link", d3.forceLink(links).id(d => d.id).distance(500))
  .force("boundary", d3.forceRadial(
    d => circleLayouts[d.type].radius, 
    d => circleLayouts[d.type].center[0], 
    d => circleLayouts[d.type].center[1]))
  .on("tick", ticked);

function ticked() {
  nodes.forEach(boundaryForce);
  
  node.attr("cx", d => d.x)
      .attr("cy", d => d.y);

      link.attr("d", d => {
        if (d.source && d.target) {
            return linkPath({ source: d.source, target: d.target });
        } else {
            console.warn('Link has undefined source or target:', d);
            return ""; // or handle it appropriately
        }
    });

  labels.attr("x", d => d.x)
        .attr("y", d => d.y + 10);
}

      // Functions for drag behavior
      function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      }

      function dragged(event) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      }

      function dragended(event) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      }

      // Function to handle mouse hover over nodes
function mouseOver(event, d) {
    // Highlight the hovered node
    d3.select(this).attr("stroke", "black").attr("stroke-width", 2);
}

// Function to handle mouse out from nodes
function mouseOut(event, d) {
    // Remove the highlight from the node
    d3.select(this).attr("stroke", null).attr("stroke-width", null);
}

function clicked(event, d) {
  clickedActive = true;

  // Reset all nodes and links to normal state
  node.style("opacity", 0.4).style("font-weight", "normal").style("stroke", "#ccc"); // Gray out non-selected nodes
  link.style("stroke", "#ccc").style("stroke-width", 0.075);
  labels.style("visibility", "hidden"); // Hide all labels by default

  // Highlight clicked node
  d3.select(this)
    .style("opacity", 1) // Make selected node fully visible
    .style("font-weight", "bold")
    .style("stroke", "black")
    .style("stroke-width", "2px");

  // Show label of clicked node
  labels.filter(label => label.id === d.id)
    .style("visibility", "visible");

  // Highlight links between clicked node and neighboring nodes
  link.filter(link => link.source.id === d.id || link.target.id === d.id)
    .style("stroke", "black")
    .style("stroke-width", "0.34px");

  // Highlight neighboring nodes
  const neighboringNodes = links.reduce((acc, link) => {
    if (link.source.id === d.id) {
      acc.push(link.target.id); // Include only target nodes' IDs
    } else if (link.target.id === d.id) {
      acc.push(link.source.id);
    }
    return acc;
  }, []);

  console.log(neighboringNodes);

  // Apply transformation to neighboring nodes
  node.filter(node => neighboringNodes.includes(node.id))
    .style("opacity", 1) // Make neighboring nodes fully visible
    .style("font-weight", "bold")
    .style("stroke", "black")
    .style("stroke-width", "1.05px");
  

  // Append a drop shadow filter to the SVG
const filter = svg.append("filter")
                  .attr("id", "drop-shadow")
                  .attr("x", "-20%")
                  .attr("y", "-20%")
                  .attr("width", "140%")
                  .attr("height", "140%");

filter.append("feDropShadow")
      .attr("dx", "1")
      .attr("dy", "1")
      .attr("stdDeviation", "1")
      .attr("flood-color", "rgba(0, 0, 0, 0.5)");

  // Show labels for neighboring nodes
  labels.filter(label => neighboringNodes.includes(label.id))
    .style("visibility", "visible");

  // Display cluster labels for neighboring node types
  const neighboringNodeTypes = new Set(neighboringNodes.map(nodeId => nodes.find(node => node.id === nodeId).type));

  neighboringNodeTypes.forEach(type => {
    const clusterNodes = nodes.filter(node => neighboringNodes.includes(node.id) && node.type === type);
    if (clusterNodes.length > 0) {
      // Calculate centroid of the cluster
      const centroidX = d3.mean(clusterNodes, node => node.x);
      const centroidY = d3.mean(clusterNodes, node => node.y);

      // Determine label position adjustment based on node position
    let labelOffsetX = 0;
    if (centroidX > d.x) {
      labelOffsetX = 130; // Label is to the right of the node
    } else {
      labelOffsetX = -130; // Label is to the left of the node
    }

      // Create or update label for the cluster
      let clusterLabel = svg.select(`#cluster-label-${type.replace(/\s+/g, '-')}`);
      if (clusterLabel.empty()) {
        clusterLabel = svg.append("text")
                          .attr("id", `cluster-label-${type.replace(/\s+/g, '-')}`)
                          .attr("text-anchor", "middle")
                          .attr("alignment-baseline", "middle")
                          .text(type)
                          .style("font-family", "'SFPro', sans-serif")
                          .style("font-size", "12px")
                          .style("font-weight", "bold")
                          .style("pointer-events", "none")
                          .style("visibility", "hidden"); // Initially hidden
      }

      // Set fill color based on type using colorScheme
    clusterLabel.style("fill", colorScheme[type])
                .style("filter", "url(#drop-shadow)");


      // Update label position near the centroid
      clusterLabel.attr("x", centroidX + labelOffsetX)
                  .attr("y", centroidY) // Adjust vertical offset as needed
                  .style("visibility", "visible"); // Show the cluster label
    }
  });

  // Prevent event propagation
  event.stopPropagation();
}


// Add event listener for click on nodes
node.on("click", clicked);


// Function to handle unclick event on the white space
function unclicked(event) {

  clickedActive = false;
  
  // Reset all nodes to normal state
  node.style("opacity", 1).style("font-weight", "normal").style("stroke", "none");
  link.style("stroke", "#333").style("stroke-width", 0.075);
  labels.style("visibility", "hidden");

  svg.selectAll("[id^='cluster-label-']").style("visibility", "hidden");
}

// Add event listener for click on white space to unclick
svg.on("click", unclicked);



// Add event listeners for mouseover and mouseout
node.on("mouseover", mouseOver).on("mouseout", mouseOut);


      // Function to detect and prevent label overlap
      function labelCollisionDetection(labels) {
        const labelNodes = labels.nodes();
        for (let i = 0; i < labelNodes.length; i++) {
          for (let j = i + 1; j < labelNodes.length; j++) {
            const label1 = labelNodes[i];
            const label2 = labelNodes[j];
            const bbox1 = label1.getBBox();
            const bbox2 = label2.getBBox();
            if (bboxOverlap(bbox1, bbox2)) {
              const dx = (bbox2.x + bbox2.width / 2) - (bbox1.x + bbox1.width / 2);
              const dy = (bbox2.y + bbox2.height / 2) - (bbox1.y + bbox1.height / 2);
              const angle = Math.atan2(dy, dx);
              const overlapDistance = Math.sqrt(dx * dx + dy * dy);
              const moveX = Math.cos(angle) * overlapDistance;
              const moveY = Math.sin(angle) * overlapDistance;
              label1.setAttribute("x", parseFloat(label1.getAttribute("x")) - moveX);
              label1.setAttribute("y", parseFloat(label1.getAttribute("y")) - moveY);
            }
          }
        }
      }

      // Function to check if two bounding boxes overlap
      function bboxOverlap(bbox1, bbox2) {
        return bbox1.x < bbox2.x + bbox2.width &&
               bbox1.x + bbox1.width > bbox2.x &&
               bbox1.y < bbox2.y + bbox2.height &&
               bbox1.y + bbox1.height > bbox2.y;
      }

      // Define boundary coordinates
      const boundary = { xMin: 50, xMax: 750, yMin: 50, yMax: 550 };

      // Create forceX and forceY to keep nodes within boundaries
      const forceX = d3.forceX().x(d => Math.max(boundary.xMin, Math.min(boundary.xMax, d.x)));
      const forceY = d3.forceY().y(d => Math.max(boundary.yMin, Math.min(boundary.yMax, d.y)));

      // Add forceX and forceY to simulation
      simulation.force("boundaryX", forceX);
      simulation.force("boundaryY", forceY);

      // Function to toggle label visibility based on zoom level
      function toggleVisibility(zoomLevel) {
        if (clickedActive == false){
    labels.style("visibility", d => {
    if (zoomLevel >= 1 && d.type === "Activity Type Name") {
      return "visible";
    } else if (zoomLevel >= 0.25 && d.type === "Activity Name") {
      return "visible"; // Adjusted zoom level here
    } else if (zoomLevel >= 1.35 && (d.type === "Skill Name" || 
                                  d.type === "Excercise Name" || 
                                  d.type === "Drill Name" || 
                                  d.type === "Professional Name" || 
                                  d.type === "Equipment Name" || 
                                  d.type === "Brand Name" || 
                                  d.type === "Rule Name" || 
                                  d.type === "Excercise Type Name" ||
                                  d.type === "Motion Name" ||
                                  d.type === "Methodology Name" ||
                                  d.type === "Analysis Name")) {
      return "visible";
    } else {
      return "hidden";
    }
  });
}

}
    });
  
    function showLegend() {
    const legendContainer = document.getElementById("legend-container");
    const toggleButton = document.getElementById("show-legend");

    // Toggle the hidden class on the legend container
    legendContainer.classList.toggle("hidden");

    // Update button text based on legend container visibility
    if (legendContainer.classList.contains("hidden")) {
      toggleButton.textContent = "Show Legend";
    } else {
      toggleButton.textContent = "Hide Legend";
    }
  }

  function searchNode() {
  const searchTerm = document.getElementById("node-search").value.trim().toLowerCase();
  
  // Check if nodes array is defined and not empty
  if (nodes && nodes.length > 0) {
    // Find the node by name
    const foundNode = nodes.find(node => node.id.toLowerCase() === searchTerm);

    // If node found, trigger click event on that node
    if (foundNode) {
      // Select the corresponding node element and trigger the 'clicked' function
      const nodeElement = svg.selectAll(".node")
                             .filter(d => d.id === foundNode.id);
      if (!nodeElement.empty()) {
        nodeElement.dispatch('click'); // Trigger the click event
      } else {
        console.log(`Node with id '${foundNode.id}' not found in the SVG.`);
      }
    } else {
      console.log(`Node with id '${searchTerm}' not found.`);
      // Handle case where node is not found (e.g., show message, clear selection)
    }
  } else {
    console.log("Nodes array is empty or undefined.");
    // Handle case where nodes array is empty or undefined
  }
}

  </script>
</body>
</html>